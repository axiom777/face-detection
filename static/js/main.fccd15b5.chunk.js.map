{"version":3,"sources":["App.tsx","reportWebVitals.ts","index.tsx","App.module.css"],"names":["detectFace","image","setState","a","MODEL_URL","detectionStatus","faceapi","withFaceLandmarks","withFaceDescriptors","fullFaceDescriptions","App","props","imageAvatarRef","canvasAvatarRef","imageRef","fileUrl","handleOnSelectFile","e","target","files","length","reader","FileReader","onload","result","src","modalVisible","readAsDataURL","onImageLoaded","onCropComplete","crop","makeClientCrop","onCropChange","_","percentCrop","state","croppedImageUrl","unit","width","aspect","React","createRef","handleToggleCamera","bind","handleDetectFace","handleSave","prevState","this","console","log","current","height","dimensions","clientWidth","clientHeight","resized","canvas","drawDetections","drawFaceLandmarks","stateCallBack","fileName","document","createElement","pixelRatio","window","devicePixelRatio","scaleX","naturalWidth","scaleY","naturalHeight","ctx","getContext","setTransform","imageSmoothingQuality","drawImage","x","y","Promise","resolve","toBlob","blob","newBlob","name","URL","revokeObjectURL","createObjectURL","error","getCroppedImg","className","styles","Avatar","alt","ref","buttons","type","accept","onChange","onClick","modal","modalContainer","ruleOfThirds","onComplete","Component","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById","module","exports"],"mappings":"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","file":"static/js/main.fccd15b5.chunk.js","sourcesContent":["import React from \"react\";\nimport * as faceapi from \"face-api.js\";\nimport styles from \"./App.module.css\";\nimport ReactCrop, { Crop } from \"react-image-crop\";\nimport \"react-image-crop/dist/ReactCrop.css\";\n\ntype FullFaceDescriptions = faceapi.WithFaceDescriptor<\n  faceapi.WithFaceLandmarks<\n    {\n      detection: faceapi.FaceDetection;\n    },\n    faceapi.FaceLandmarks68\n  >\n>[];\n\nasync function detectFace(\n  image: HTMLImageElement,\n  setState: Function\n): Promise<FullFaceDescriptions> {\n  // const MODEL_URL = \"/weights\";\n  const MODEL_URL = \"https://axiom777.github.io/face-detection/weights\";\n  setState({ detectionStatus: \"Load SsdModel\" });\n\n  await faceapi.loadSsdMobilenetv1Model(MODEL_URL);\n  setState({ detectionStatus: \"Load LandmarkModel\" });\n\n  await faceapi.loadFaceLandmarkModel(MODEL_URL);\n  setState({ detectionStatus: \"Load RecognitionModel\" });\n\n  await faceapi.loadFaceRecognitionModel(MODEL_URL);\n  setState({ detectionStatus: \"Detection\" });\n  let fullFaceDescriptions = await faceapi\n    .detectAllFaces(image)\n    .withFaceLandmarks()\n    .withFaceDescriptors();\n  return fullFaceDescriptions;\n}\n\ninterface Props {}\ninterface State {\n  fullFaceDescriptions: FullFaceDescriptions | null;\n  crop: Partial<Crop>;\n  src: string | null;\n  croppedImageUrl: any;\n  modalVisible: boolean;\n  detectionStatus: string;\n}\n\nclass App extends React.Component<Props, State> {\n  private imageAvatarRef: React.RefObject<HTMLImageElement>;\n  private canvasAvatarRef: React.RefObject<HTMLCanvasElement>;\n  private imageRef: HTMLImageElement | null = null;\n  private fileUrl: any;\n\n  constructor(props: Props) {\n    super(props);\n\n    this.state = {\n      fullFaceDescriptions: null,\n      croppedImageUrl: \"\",\n      src: null,\n      crop: {\n        unit: \"%\",\n        width: 270,\n        aspect: 1,\n      },\n      modalVisible: false,\n      detectionStatus: \"\",\n    };\n\n    this.imageAvatarRef = React.createRef<HTMLImageElement>();\n    this.canvasAvatarRef = React.createRef<HTMLCanvasElement>();\n    this.handleToggleCamera = this.handleToggleCamera.bind(this);\n    this.handleDetectFace = this.handleDetectFace.bind(this);\n    this.onImageLoaded = this.onImageLoaded.bind(this);\n    this.onCropComplete = this.onCropComplete.bind(this);\n    this.onCropChange = this.onCropChange.bind(this);\n    this.handleSave = this.handleSave.bind(this);\n  }\n\n  componentDidUpdate(_: Props, prevState: State) {\n    let { fullFaceDescriptions } = this.state;\n    if (prevState.fullFaceDescriptions !== fullFaceDescriptions) {\n      console.log(\"1\");\n      console.log(\n        this.imageAvatarRef.current!.width,\n        this.imageAvatarRef.current!.height\n      );\n\n      const dimensions = {\n        width: this.imageAvatarRef.current!.clientWidth,\n        height: this.imageAvatarRef.current!.clientHeight,\n      };\n      const resized = faceapi.resizeResults(fullFaceDescriptions, dimensions);\n      const canvas = this.canvasAvatarRef.current;\n      console.log(\"2\");\n      if (canvas !== null && resized !== null) {\n        faceapi.draw.drawDetections(canvas, resized);\n        faceapi.draw.drawFaceLandmarks(canvas, resized);\n        console.log(\"3\");\n      }\n    }\n  }\n\n  handleToggleCamera() {}\n\n  async handleDetectFace() {\n    const image = this.imageAvatarRef.current;\n    if (image !== null) {\n      const stateCallBack = this.setState.bind(this);\n      const result = await detectFace(image, stateCallBack);\n      this.setState({ fullFaceDescriptions: result });\n    }\n  }\n\n  handleOnSelectFile = (e: React.ChangeEvent<HTMLInputElement>) => {\n    if (e.target.files && e.target.files.length > 0) {\n      const reader = new FileReader();\n      reader.onload = () => {\n        const { result } = reader;\n        if (typeof result === \"string\") {\n          this.setState({ src: result, modalVisible: true });\n        }\n      };\n      reader.readAsDataURL(e.target.files[0]);\n    }\n  };\n\n  handleSave() {\n    const { croppedImageUrl } = this.state;\n    this.setState({\n      src: croppedImageUrl,\n      modalVisible: false,\n    });\n  }\n\n  getCroppedImg(image: HTMLImageElement, crop: Crop, fileName: string) {\n    const canvas = document.createElement(\"canvas\");\n    const pixelRatio = window.devicePixelRatio;\n    const scaleX = image.naturalWidth / image.width;\n    const scaleY = image.naturalHeight / image.height;\n    const ctx = canvas.getContext(\"2d\");\n\n    canvas.width = crop.width * pixelRatio * scaleX;\n    canvas.height = crop.height * pixelRatio * scaleY;\n\n    ctx!.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n    ctx!.imageSmoothingQuality = \"high\";\n\n    ctx!.drawImage(\n      image,\n      crop.x * scaleX,\n      crop.y * scaleY,\n      crop.width * scaleX,\n      crop.height * scaleY,\n      0,\n      0,\n      crop.width * scaleX,\n      crop.height * scaleY\n    );\n\n    return new Promise((resolve) => {\n      canvas.toBlob(\n        (blob) => {\n          if (!blob) {\n            //reject(new Error('Canvas is empty'));\n            console.error(\"Canvas is empty\");\n            return;\n          }\n          const newBlob: Blob & { name?: string } = blob;\n          newBlob.name = fileName;\n          window.URL.revokeObjectURL(this.fileUrl);\n          this.fileUrl = window.URL.createObjectURL(newBlob);\n          resolve(this.fileUrl);\n        },\n        \"image/jpeg\",\n        1\n      );\n    });\n  }\n\n  async makeClientCrop(crop: Crop) {\n    if (this.imageRef && crop.width && crop.height) {\n      const croppedImageUrl = await this.getCroppedImg(\n        this.imageRef,\n        crop,\n        \"newFile.jpeg\"\n      );\n      this.setState({ croppedImageUrl });\n    }\n  }\n\n  onImageLoaded = (image: HTMLImageElement) => {\n    this.imageRef = image;\n  };\n\n  onCropComplete = (crop: Crop) => {\n    this.makeClientCrop(crop);\n  };\n\n  onCropChange = (_: Crop, percentCrop: Crop) => {\n    // You could also use percentCrop:\n    // this.setState({ crop: percentCrop });\n    this.setState({ crop: percentCrop });\n  };\n\n  render() {\n    const {\n      src,\n      crop,\n      croppedImageUrl,\n      modalVisible,\n      detectionStatus,\n    } = this.state;\n    return (\n      <div>\n        <div className={styles.App}>\n          <div className={styles.Avatar}>\n            {src !== null && (\n              <img src={src} alt=\"Avatar\" ref={this.imageAvatarRef} />\n            )}\n            <canvas ref={this.canvasAvatarRef}></canvas>\n            <span>{detectionStatus}</span>\n          </div>\n          <div className={styles.buttons}>\n            <input\n              type=\"file\"\n              accept=\"image/jpeg,image/png\"\n              onChange={this.handleOnSelectFile}\n            />\n            <button onClick={this.handleToggleCamera}>toggleCamera</button>\n            <button onClick={this.handleDetectFace}>DetectFace</button>\n          </div>\n        </div>\n        {src && modalVisible && (\n          <div className={styles.modal}>\n            <div className={styles.modalContainer}>\n              <ReactCrop\n                src={src}\n                crop={crop}\n                ruleOfThirds\n                onImageLoaded={this.onImageLoaded}\n                onComplete={this.onCropComplete}\n                onChange={this.onCropChange}\n              />\n              <div>\n                <img alt=\"Crop\" src={croppedImageUrl} />\n                <button onClick={this.handleSave}>Save</button>\n              </div>\n            </div>\n          </div>\n        )}\n      </div>\n    );\n  }\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"App\":\"App_App__16ZpL\",\"Avatar\":\"App_Avatar__ha_wO\",\"buttons\":\"App_buttons__32eX7\",\"modal\":\"App_modal__Ayqb5\",\"modalContainer\":\"App_modalContainer__3QGBJ\"};"],"sourceRoot":""}